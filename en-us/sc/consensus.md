---
name: Consensus

---

## 1 - List of Terms

* **Proof of Stake** `PoS`  A type of algorithm which uses network consensus to handle fault tolerance.

* **Proof of Work** `PoW` - A type of algorithm which uses compute utility to handle fault tolerance.

* **Byzantine Fault** `BF` - A failure in which a node remains functional, but operates in a dishonest manner.

* **Practical Byzantine Fault Tolerance** `PBFT` - A consensus algorithm implemented within the AntShares blockchain to guarantee fault tolerance.

* **View** - The data set used during a consensus instance in AntShares PBFT

## 2 - Introduction

## 3 - Background

One of the fundamental differences between blockchains is how they guarantee fault tolerance due to faulty or dishonest activity on the network.

Traditional methods implemented using PoW can provide this guarantee as long as a majority of the network's computational power is honest. 
However, because of PoW's dependency on compute, the mechanism can be very resource intensive (due to the energy cost of computation). 
These dependencies expose a PoW network to a number of limitations, the primary one being the cost of scaling.

**(Describe conventional PoS mechanic)**

AntShares implements a PoS algorithm using Practical Byzantine Fault Tolerance which protects the network from Byzantine faults using minimal resources.
This solution provides an effective solution to performance and scalability issues associated with current blockchain implementations without significant impact to fault tolerance capabilities.

## 4 - Theory

**(Outline Byzantine Generals Problem)**

## 5 - Practical Implementation
The practical implementation of PBFT in AntShares uses an iterative consensus method to guarantee that consensus is reached.  The performance of the algorithm is dependent on the fraction of dishonest nodes in the system.  The chart below depicts the
expected iterations as a function of the fraction of dishonest nodes.

**{insert equation and plot}**


### 5.1 - Roles
**In AntShares, there are two primary roles that nodes can inherit:**

1. **Consensus Node** - This node participates in consensus activity.  During consensus activity, consensus nodes take turns assuming the following two roles:
    - **Speaker** `(One)` - The speaker is analogous to the general in section 4.  They are responsible for transmitting a block proposal to the system.
    - **Congressman** `(Multiple)` - Congressman nodes are analogous to the lieutenant in section 4.  They are responsible for reaching a consensus on the transaction.
  
2. **Bookkeeper Node** `(Multiple)` - The bookkeeper nodes act as scribes and digitally sign the blocks that are generated by consensus nodes.  They must agree with the result of the consensus activity to sign the block.



### 5.2 - Definitions

**Within the algorithm, we define the following:**

  - `t` (seconds): This is the atomic unit of time allocated for block generation.

	
  - `n`: The number of active **Consensus Nodes**
 
	
  - `f`: The minimum threshold of faulty **Consensus Nodes** within the system. 
  	- f = (n - 1) / 3.
  
	
  - `h` : The current block height during consensus activity

	
  - `i` : **Consensus Node** index
  
  
  - `v` : The view of a **Consensus Node**.  The view contains the aggregated information the node has received during a round of consensus.


  - `k` : The index of the view `v`.  A consensus activity can require multiple rounds.  On consensus failure, `k` is incremented and a new round of consensus begins.

  
  - `p` : Index of the **Consensus Node** elected as the **Speaker**.  
  	- p = (h - k) mod (n)
  

  - `s`: The safe consensus threshold.  Below this threshold, the network is exposed to fault.  
  	- s = (n - f)


### 5.3 - Requirements

**Within AntShares, there are five primary requirements for consensus fault tolerance:**

1. `s` number of **Congressmen** must reach a consensus about a transaction before a block can be committed.


2. Dishonest **Consensus Nodes** must not be able to persuade the honest consensus nodes of faulty transactions. 


3. `s` number of **Bookkeepers** must reach consensus about the block produced by the consensus activity.	

  
4. If the generated block is honest, all honest **Bookkeepers** are in agreement with the honest **Congressmen**.


5. At least `s` number of **Consensus Nodes** are in the same state (`h`,`k`) to begin a conensus activity.

	
### 5.3 - Algorithm
**The algorithm works as follows:**

1. A consensus node broadcasts a transaction to the entire network with the sender's signatures.

2. **Bookkeeper nodes** log transaction data into local memory.

3. The view `v` is initialized.

4. The **Speaker** is identified.
	
  **Wait** `t` seconds
	
5. The **Speaker** broadcasts the proposal :
    <!-- -->
        <prepareRequest, h, k, p, bloc, [block]sigp>

6. The **Congressmen** receive the proposal and validate:

    - Is the data format consistent with system rules?
    - Is the transaction already on the blockchain?
    - Are the contract scripts correctly executed?
    - Does the transaction only contain a single spend?	(i.e. does the transaction avoid a double spend scenario?)

    - **If Validated Proposal Broadcast:**
	    <!-- -->
	        <prepareResponse, h, k, i, [block]sigi>
	 	
    - **If Invalidated Proposal Broadcast:**
	    <!-- -->
	        <ChangeView, h,k,i,k+1>

7. After receiving `s` number of 'prepareResponse' broadcasts, a **Congressman** reaches a consensus and publishes a block.

8. At least `s` number of **Bookkeepers** sign the published block.

8. When a **Consensus Node** receives a full block, current view data is purged, and a new round of consensus begins. 
	- `k = 0`
 
--- 
  
**Note:**
 
 If after   (![timeout](assets/consensus.timeout.png) )  seconds on the same view without consensus:
  - **Consensus Node** broadcasts:

	<!-- -->
	    <ChangeView, h,k,i,k+1>
		
  - Once a **Consensus Node** receives at least `s` number of broadcasts denoting the same change of view, it increments the view `v`, triggering a new round of consensus.
	
	
## Example 
 
 
# Questions:
  - How is spoofing prevented?	
  - How is `n` calculated?
  - Further information on bookkeepers
  - Further information on synchronicity
  - Further information on penalization (for dishonest nodes?)
	

## References
1. [The Byzantine Generals Problem](http://www-inst.eecs.berkeley.edu/~cs162/fa12/hand-outs/Original_Byzantine.pdf)
2. [Practical Byzantine Fault Tolerance](https://kelehers.me/others/pbftByzantine.pdf)
3. [A Byzantine Fault Tolerance Algorithm for Blockchain](https://www.antshares.org/Files/A8A0E2.pdf)
